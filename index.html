<html>

<head>
  <title>Plane-Game</title>
  <link rel="shortcut icon" href="">
  <style>
    body {
      margin: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
    }

    ;
  </style>

</head>

<body>
  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/GLTFLoader.js"></script>
  <script src="js/PointerLockControls.js"></script>


  <script>
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);
    var rotateUp = false;
    var rotateDown = false;
    var rotateLeft = false;
    var rotateRight = false;
    var playSound = false;
    var renderer = new THREE.WebGLRenderer();
    var score = 0;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });
    // var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
    // var pointerLockControls = new THREE.PointerLockControls(camera);
    //  scene.add(pointerLockControls.getObject());
    // create an AudioListener and add it to the camera
    var listener = new THREE.AudioListener();
    camera.add(listener);
    // create a global audio source
    var sound = new THREE.Audio(listener);
    // load a sound and set it as the Audio object's buffer
    var audioLoader = new THREE.AudioLoader();
    audioLoader.load('sounds/dangerZone.mp3', function (buffer) {
      sound.setBuffer(buffer);
      sound.setLoop(true);
      sound.setVolume(0.5);
    });
    var onKeyDown = function (event) {
      switch (event.keyCode) {
        case 87: // w
          rotateDown = true;
          break;
        case 65: // a
          rotateLeft = true;
          break;
        case 83: // s
          rotateUp = true;
          break;
        case 68: // d
          rotateRight = true;
          break;
        case 80: // p
          playSound = !playSound
          if(playSound)
            sound.play();
          else 
            sound.stop();
      }
    }
    var onKeyUp = function (event) {
      switch (event.keyCode) {
        case 87: // w
          rotateDown = false;
          break;
        case 65: // a
          rotateLeft = false;
          break;
        case 83: // s
          rotateUp = false;
          break;
        case 68: // d
          rotateRight = false;
          break;
      }
    };
    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);
    camera.position.z = 10;
    camera.position.y = 1;
    var ambientLight = new THREE.AmbientLight(0xFFFFFF, 25.0);
    scene.add(ambientLight);
    var spotLight1 = new THREE.SpotLight(0xff00000, 10);
    var spotLight2 = new THREE.SpotLight(0x00000ff, 10);
    spotLight1.position.set(0, 3, 0);
    spotLight2.position.set(0, -3, 0);
    scene.add(spotLight1);
    scene.add(spotLight2);
    // game logic
    var model;
    var loader = new THREE.GLTFLoader();
    loader.load(
      'models/F_22_Raptor.glb',
      function (gltf) {
        model = gltf;
        scene.add(model.scene);
        model.scene.rotateY(THREE.Math.degToRad(180));
      }, undefined,
      function (error) {
        console.error(error);
      }
    );

    function componentToHex(val) {
      var hex = val.toString(16);
      return hex.length == 1 ? "0" + hex : hex;
    }

    function rgbToHex(r, g, b) {
      return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
    }

    function hslToRgb(h, s, l){
        var r, g, b;

        if(s == 0){
            r = g = b = l; // achromatic
        }else{
            var hue2rgb = function hue2rgb(p, q, t){
                if(t < 0) t += 1;
                if(t > 1) t -= 1;
                if(t < 1/6) return p + (q - p) * 6 * t;
                if(t < 1/2) return q;
                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }




    const distance = -200;
    const nextDistance = 150;
    const spawnRange = 50;

    const ringRadius = 7;
    const tubeSize = 2;

    const trueRadius = ringRadius-tubeSize;


    function ringInit(numRings) {

      var rings = [];

      for (var i = 0; i < numRings; i++){

        var initTranslateRing = new THREE.Matrix4().makeTranslation(spawnRange * (1 - 2 * Math.random()), spawnRange * (
          1 - 2 * Math.random()), (distance - (nextDistance * i)) );

        var ringGeometry = new THREE.TorusGeometry(ringRadius, tubeSize, 6, 30);

        var rgb = rgbToHex(255,0,255);
        var hsl = hslToRgb(Math.random(), .8, .5);
        console.log(hsl);
        var color = rgbToHex(hsl[0],hsl[1],hsl[2]);

        //hslToRgb(.8, .8, .8)

        var ringMaterial = new THREE.MeshBasicMaterial({
          color: color//rgbToHex(color[0],color[1],color[2])
        });

        var ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.matrixAutoUpdate = false;

        ring.matrix.multiply(initTranslateRing);
        rings.push(ring);
      }
      return rings;

    };

    this.rings = ringInit(30);
    console.log(this.rings);


    this.resetTranslateRing = new THREE.Matrix4().makeTranslation(spawnRange * (1 - 2 * Math.random()), spawnRange * (
      1 - 2 * Math.random()), (-1 * (10 * nextDistance)));




    var skyGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
    var cubeMaterials = [
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_bk.png'),
        side: THREE.DoubleSide
      }), //RIGHT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_ft.png'),
        side: THREE.DoubleSide
      }), //LEFT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_up.png'),
        side: THREE.DoubleSide
      }), //TOP SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_dn.png'),
        side: THREE.DoubleSide
      }), //BOTTOM SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_lf.png'),
        side: THREE.DoubleSide
      }), //FRONT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_rt.png'),
        side: THREE.DoubleSide
      }) //BACK S
    ];


    var cube = new THREE.Mesh(skyGeometry, cubeMaterials);

    rings.forEach(function (ring) {
      scene.add(ring);
    });

    scene.add(cube);
    var horSpeed = 6;
    var vertSpeed = 2;
    var vertAngleCap = 20;
    var vertAngle = 0;
    var horAngle = 0;
    this.resetY = new THREE.Matrix4().makeTranslation(1.0, 0.0, 1.0);
    var update = function () {
      var time = Date.now() * 0.0005;

      this.moveRingUp = new THREE.Matrix4().makeTranslation(0.0, 0.5, 0.0);
      this.moveRingDown = new THREE.Matrix4().makeTranslation(0.0, -0.5, 0.0);
      this.moveRingLeft = new THREE.Matrix4().makeTranslation(-0.5, 0.0, 0.0);
      this.moveRingRight = new THREE.Matrix4().makeTranslation(0.5, 0.0, 0.0);
      try {
        if (rotateDown) {
          if (vertAngle <= vertAngleCap && horAngle == 0 && !rotateLeft && !rotateRight) {
            model.scene.rotateX(THREE.Math.degToRad(vertSpeed));
            vertAngle += vertSpeed;
          }
          rings.forEach(function (ring) {
            ring.matrix.premultiply(this.moveRingUp);
          });
        }
        if (rotateLeft) {
          //    if (vertAngle == 0) {
          model.scene.rotateZ(THREE.Math.degToRad(-horSpeed));
          horAngle -= horSpeed;
          horAngle %= 360;
          //     }
          rings.forEach(function (ring) {
            ring.matrix.premultiply(this.moveRingRight);
          });
        }
        if (rotateUp) {
        if (vertAngle >= -vertAngleCap && horAngle == 0 && !rotateLeft && !rotateRight) {
            model.scene.rotateX(THREE.Math.degToRad(-vertSpeed));
            vertAngle -= vertSpeed
          }
          rings.forEach(function (ring) {
            ring.matrix.premultiply(this.moveRingDown);
          });
        }
        if (rotateRight) {
          //  if (vertAngle == 0) {
          model.scene.rotateZ(THREE.Math.degToRad(horSpeed));
          horAngle += horSpeed;
          horAngle %= 360;
          //     }
          rings.forEach(function (ring) {
            ring.matrix.premultiply(this.moveRingLeft);
          });
        }

        //stabilizes the horizontal angle of the plane
        if (!rotateLeft && !rotateRight && horAngle != 0) {
          var adjustment = horSpeed;
          //spin right defaults to stabilizing left, visa versa
          if (horAngle > 0) {
            adjustment *= -1;
          }
          //if the plane spins past 90 degrees, it will flip the way it stabilizes
          if (Math.abs(horAngle) > 90)
            adjustment *= -1;
          model.scene.rotateZ(THREE.Math.degToRad(adjustment));
          horAngle += adjustment;
          horAngle %= 360;
        }
        const rate = 0.01;

        if (!rotateDown && !rotateUp) {
          if (3.14 - Math.abs(model.scene.rotation.x) > .1) {
            if (model.scene.rotation.x < 0)
              model.scene.rotation.x -= rate;
            else
              model.scene.rotation.x += rate;
          }
          else{
            vertAngle = 0;
          }
        }
        model.scene.rotation.y = 0;




        //model.scene.position.x = Math.sin(time * 0.7) * 30;
      } catch (TypeError) {
        //console throws an error if the previous isn't in a try catch
      }
    };
    // draw scene
    var render = function () {
      this.rotZ1 = new THREE.Matrix4().makeRotationZ(THREE.Math.degToRad(1));
      rings.forEach(function (ring) {
        ring.matrix.multiply(this.rotZ1);
      });
      this.moveRingTowardsPlayer = new THREE.Matrix4().makeTranslation(0.0, 0.0, 0.5);
      rings.forEach(function (ring) {
        ring.matrix.premultiply(this.moveRingTowardsPlayer);
      });
      this.position = new THREE.Vector3();
      rings.forEach(function (ring) {
        ring.getWorldPosition(position);
        if (position.z > 0) {
          ring.matrix.premultiply(resetTranslateRing);
        }
      });
      renderer.render(scene, camera);
    };

    function checkCollisions(){

      this.position = new THREE.Vector3();
      rings.forEach(function (ring) {
        ring.getWorldPosition(position);
        const tolerance = .2;
        if(position.z <= tolerance && position.z >= -tolerance){

          sq_dist = getSquaredDistanceFromPlane(position.x,position.y);
          sq_ringRadius = trueRadius*trueRadius;

          if( sq_dist <= sq_ringRadius ){
            score++;
            console.log(score);
            return score;
          }

        }
      });
    };
    function getSquaredDistanceFromPlane(x, y){

      return (x*x + y*y);

    };








    // run game loop: update, render, repeat
    var GameLoop = function () {
      requestAnimationFrame(GameLoop);
      update();
      checkCollisions();
      render();
    };
    GameLoop();
  </script>
</body>

</html>
