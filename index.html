<html>

<head>
  <title>Three.js Tutorial</title>

  <style>
    body {
      margin: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
    }

    ;
  </style>

</head>

<body>
  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/GLTFLoader.js"></script>
  <script src="js/PointerLockControls.js"></script>


  <script>
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);

    var rotateUp = false;
    var rotateDown = false;
    var rotateLeft = false;
    var rotateRight = false;

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });

    // var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
    // var pointerLockControls = new THREE.PointerLockControls(camera);
    //  scene.add(pointerLockControls.getObject());
    // create an AudioListener and add it to the camera
    var listener = new THREE.AudioListener();
    camera.add(listener);

    // create a global audio source
    var sound = new THREE.Audio(listener);

    // load a sound and set it as the Audio object's buffer
    var audioLoader = new THREE.AudioLoader();
    audioLoader.load('sounds/dangerZone.mp3', function (buffer) {
      sound.setBuffer(buffer);
      sound.setLoop(true);
      sound.setVolume(0.5);
      sound.play();
    });

    var onKeyDown = function (event) {
      switch (event.keyCode) {
        case 87: // w
          rotateDown = true;
          break;

        case 65: // a
          rotateLeft = true;
          break;

        case 83: // s
          rotateUp = true;
          break;

        case 68: // d
          rotateRight = true;
          break;

      }
    }

    var onKeyUp = function (event) {
      switch (event.keyCode) {
        case 87: // w
          rotateDown = false;
          break;

        case 65: // a
          rotateLeft = false;
          break;

        case 83: // s
          rotateUp = false;
          break;

        case 68: // d
          rotateRight = false;
          break;
      }
    };

    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);

    camera.position.z = 10;
    camera.position.y = 1;

    var ambientLight = new THREE.AmbientLight(0x0000FF, 25.0);
    scene.add(ambientLight);

    var spotLight1 = new THREE.SpotLight(0xff00000, 10);
    var spotLight2 = new THREE.SpotLight(0x00000ff, 10);

    spotLight1.position.set(0, 3, 0);
    spotLight2.position.set(0, -3, 0);

    scene.add(spotLight1);
    scene.add(spotLight2);

    // game logic

    var model;

    var loader = new THREE.GLTFLoader();
    loader.load(
      'models/F_22_Raptor.glb',
      function (gltf) {
        model = gltf;
        scene.add(model.scene);
        model.scene.rotateY(THREE.Math.degToRad(180));

      }, undefined,
      function (error) {
        console.error(error);
      }
    );

    var distance = -200;
    var nextDistance = 100;

    this.initTranslateRing1 = new THREE.Matrix4().makeTranslation(0, 0, distance);
    this.initTranslateRing2 = new THREE.Matrix4().makeTranslation(50, 0, (distance - nextDistance));
    this.initTranslateRing3 = new THREE.Matrix4().makeTranslation(0, 50, (distance - (2 * nextDistance)));
    this.initTranslateRing4 = new THREE.Matrix4().makeTranslation(-50, 0, (distance - (3 * nextDistance)));
    this.initTranslateRing5 = new THREE.Matrix4().makeTranslation(0, -50, (distance - (4 * nextDistance)));
    this.initTranslateRing6 = new THREE.Matrix4().makeTranslation(50, 50, (distance - (5 * nextDistance)));
    this.initTranslateRing7 = new THREE.Matrix4().makeTranslation(-50, -50, (distance - (6 * nextDistance)));
    this.initTranslateRing8 = new THREE.Matrix4().makeTranslation(50, -50, (distance - (7 * nextDistance)));
    this.initTranslateRing9 = new THREE.Matrix4().makeTranslation(-50, 50, (distance - (8 * nextDistance)));
    this.initTranslateRing10 = new THREE.Matrix4().makeTranslation(0, 0, (distance - (9 * nextDistance)));

    var ringGeom1 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr1 = new THREE.MeshPhongMaterial({
      color: 0x000000
    });
    var ringGeom2 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr2 = new THREE.MeshPhongMaterial({
      color: 0x222222
    });
    var ringGeom3 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr3 = new THREE.MeshPhongMaterial({
      color: 0x444444
    });
    var ringGeom4 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr4 = new THREE.MeshPhongMaterial({
      color: 0x666666
    });
    var ringGeom5 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr5 = new THREE.MeshPhongMaterial({
      color: 0x888888
    });
    var ringGeom6 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr6 = new THREE.MeshPhongMaterial({
      color: 0xaaaaaa
    });
    var ringGeom7 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr7 = new THREE.MeshPhongMaterial({
      color: 0xcccccc
    });
    var ringGeom8 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr8 = new THREE.MeshPhongMaterial({
      color: 0xeeeeee
    });
    var ringGeom9 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr9 = new THREE.MeshPhongMaterial({
      color: 0xaa0000
    });
    var ringGeom10 = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr10 = new THREE.MeshPhongMaterial({
      color: 0x0000aa
    });

    this.ring1 = new THREE.Mesh(ringGeom1, ringMatr1);
    this.ring1.matrixAutoUpdate = false;
    this.ring1.matrix.multiply(this.initTranslateRing1);
    this.ring2 = new THREE.Mesh(ringGeom2, ringMatr2);
    this.ring2.matrixAutoUpdate = false;
    this.ring2.matrix.multiply(this.initTranslateRing2);
    this.ring3 = new THREE.Mesh(ringGeom3, ringMatr3);
    this.ring3.matrixAutoUpdate = false;
    this.ring3.matrix.multiply(this.initTranslateRing3);
    this.ring4 = new THREE.Mesh(ringGeom4, ringMatr4);
    this.ring4.matrixAutoUpdate = false;
    this.ring4.matrix.multiply(this.initTranslateRing4);
    this.ring5 = new THREE.Mesh(ringGeom5, ringMatr5);
    this.ring5.matrixAutoUpdate = false;
    this.ring5.matrix.multiply(this.initTranslateRing5);
    this.ring6 = new THREE.Mesh(ringGeom6, ringMatr6);
    this.ring6.matrixAutoUpdate = false;
    this.ring6.matrix.multiply(this.initTranslateRing6);
    this.ring7 = new THREE.Mesh(ringGeom7, ringMatr7);
    this.ring7.matrixAutoUpdate = false;
    this.ring7.matrix.multiply(this.initTranslateRing7);
    this.ring8 = new THREE.Mesh(ringGeom8, ringMatr8);
    this.ring8.matrixAutoUpdate = false;
    this.ring8.matrix.multiply(this.initTranslateRing8);
    this.ring9 = new THREE.Mesh(ringGeom9, ringMatr9);
    this.ring9.matrixAutoUpdate = false;
    this.ring9.matrix.multiply(this.initTranslateRing9);
    this.ring10 = new THREE.Mesh(ringGeom10, ringMatr10);
    this.ring10.matrixAutoUpdate = false;
    this.ring10.matrix.multiply(this.initTranslateRing10);

    this.rings = [ring1, ring2, ring3, ring4, ring5, ring6, ring7, ring8, ring9, ring10];

    var skyGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
    var cubeMaterials = [
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_bk.png'),
        side: THREE.DoubleSide
      }), //RIGHT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_ft.png'),
        side: THREE.DoubleSide
      }), //LEFT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_up.png'),
        side: THREE.DoubleSide
      }), //TOP SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_dn.png'),
        side: THREE.DoubleSide
      }), //BOTTOM SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_lf.png'),
        side: THREE.DoubleSide
      }), //FRONT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_rt.png'),
        side: THREE.DoubleSide
      }) //BACK S
    ];

    var cubeMaterial = new THREE.MeshFaceMaterial(cubeMaterials);
    var cube = new THREE.Mesh(skyGeometry, cubeMaterial);
    rings.forEach(function (ring) {
      scene.add(ring);
    });
    scene.add(cube);

    var horSpeed = 10;
    var vertSpeed = 2;

    var vertAngleCap = 20;
    var vertAngle = 0;
    var horAngle = 0;

    this.resetY = new THREE.Matrix4().makeTranslation(1.0, 0.0, 1.0);

    var update = function () {


      var time = Date.now() * 0.0005;

      this.moveRingUp = new THREE.Matrix4().makeTranslation(0.0, 0.5, 0.0);
      this.moveRingDown = new THREE.Matrix4().makeTranslation(0.0, -0.5, 0.0);
      this.moveRingLeft = new THREE.Matrix4().makeTranslation(-0.5, 0.0, 0.0);
      this.moveRingRight = new THREE.Matrix4().makeTranslation(0.5, 0.0, 0.0);

      try {
        if (rotateDown) {
          if (vertAngle <= vertAngleCap && horAngle == 0 && !rotateLeft && !rotateRight) {
            model.scene.rotateX(THREE.Math.degToRad(vertSpeed));
            vertAngle += vertSpeed;
          }
          rings.forEach(function (ring) {
            ring.matrix.premultiply(this.moveRingUp);
          });
        }
        if (rotateLeft) {
          //    if (vertAngle == 0) {
          model.scene.rotateZ(THREE.Math.degToRad(-horSpeed));
          horAngle -= horSpeed;
          horAngle %= 360;
          //     }
          rings.forEach(function (ring) {
            ring.matrix.premultiply(this.moveRingRight);
          });
        }
        if (rotateUp) {
          if (vertAngle >= -vertAngleCap && horAngle == 0 && !rotateLeft && !rotateRight) {
            model.scene.rotateX(THREE.Math.degToRad(-vertSpeed));
            vertAngle -= vertSpeed
          }
          rings.forEach(function (ring) {
            ring.matrix.premultiply(this.moveRingDown);
          });
        }
        if (rotateRight) {
          //  if (vertAngle == 0) {
          model.scene.rotateZ(THREE.Math.degToRad(horSpeed));
          horAngle += horSpeed;
          horAngle %= 360;
          //     }
          rings.forEach(function (ring) {
            ring.matrix.premultiply(this.moveRingLeft);
          });
        }

        //stabilizes the vertical angle of the plane
        /*     if (!rotateDown && !rotateUp && vertAngle != 0) {
               var adjustment = ((vertAngle < 0) ? 1 : -1) * vertSpeed;
               model.scene.rotateX(THREE.Math.degToRad(adjustment));
               vertAngle += adjustment;
             }*/

        //stabilizes the horizontal angle of the plane
        if (!rotateLeft && !rotateRight && horAngle != 0) {

          var adjustment = horSpeed;


          //spin right defaults to stabilizing left, visa versa
          if (horAngle > 0) {
            adjustment *= -1;
          }

          //if the plane spins past 90 degrees, it will flip the way it stabilizes
          if (Math.abs(horAngle) > 90)
            adjustment *= -1;

          model.scene.rotateZ(THREE.Math.degToRad(adjustment));
          horAngle += adjustment;
          horAngle %= 360;

        }

        var rate = 0.01;
        //(3 - model.scene.rotation.x)/4

        if (3.14 - Math.abs(model.scene.rotation.x) > .1) {
          if (model.scene.rotation.x < 0)
            model.scene.rotation.x -= rate;
          else
            model.scene.rotation.x += rate;
        }
        model.scene.rotation.y = 0;
        //model.scene.position.x = Math.sin(time * 0.7) * 30;
      } catch (TypeError) {
        //console throws an error if the previous isn't in a try catch
      }
    };

    // draw scene
    var render = function () {
      this.rotZ1 = new THREE.Matrix4().makeRotationZ(THREE.Math.degToRad(1));
      rings.forEach(function (ring) {
        ring.matrix.multiply(this.rotZ1);
      });
      this.moveRingTowardsPlayer = new THREE.Matrix4().makeTranslation(0.0, 0.0, 0.5);
      rings.forEach(function (ring) {
        ring.matrix.premultiply(this.moveRingTowardsPlayer);
      });
      renderer.render(scene, camera);

    };

    // run game loop: update, render, repeat
    var GameLoop = function () {
      requestAnimationFrame(GameLoop);

      update();
      render();
    };

    GameLoop();
  </script>
</body>

</html>