<html>

<head>
  <title>Three.js Tutorial</title>

  <style>
    body {
      margin: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
    }

    ;
  </style>

</head>

<body>
  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/GLTFLoader.js"></script>
  <script src="js/PointerLockControls.js"></script>


  <script>
    //        import Ring from './models/Ring.js';
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);

    var rotateUp = false;
    var rotateDown = false;
    var rotateLeft = false;
    var rotateRight = false;

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });

    var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
    // var pointerLockControls = new THREE.PointerLockControls(camera);
    //  scene.add(pointerLockControls.getObject());

    var onKeyDown = function (event) {
      switch (event.keyCode) {
        case 87: // w
          rotateDown = true;
          break;

        case 65: // a
          rotateLeft = true;
          break;

        case 83: // s
          rotateUp = true;
          break;

        case 68: // d
          rotateRight = true;
          break;

      }
    }

    var onKeyUp = function (event) {
      switch (event.keyCode) {
        case 87: // w
          rotateDown = false;
          break;

        case 65: // a
          rotateLeft = false;
          break;

        case 83: // s
          rotateUp = false;
          break;

        case 68: // d
          rotateRight = false;
          break;
      }
    };

    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);

    camera.position.z = 10;
    camera.position.y = 1;

    var ambientLight = new THREE.AmbientLight(0x0000FF, 25.0);
    scene.add(ambientLight);

    var spotLight1 = new THREE.SpotLight(0xff00000, 10);
    var spotLight2 = new THREE.SpotLight(0x00000ff, 10);

    spotLight1.position.set(0, 3, 0);
    spotLight2.position.set(0, -3, 0);

    scene.add(spotLight1);
    scene.add(spotLight2);

    // game logic

    var model;

    var loader = new THREE.GLTFLoader();
    loader.load(
      'models/F_22_Raptor.glb',
      function (gltf) {
        model = gltf;
        scene.add(model.scene);
        model.scene.rotateY(THREE.Math.degToRad(180));

      }, undefined,
      function (error) {
        console.error(error);
      }
    );

    this.initTranslateRing = new THREE.Matrix4().makeTranslation(0, 0, -200);
    var ringGeom = new THREE.TorusGeometry(7, 2, 6, 30);
    var ringMatr = new THREE.MeshPhongMaterial({
      color: 0x82332a
    });
    this.ring = new THREE.Mesh(ringGeom, ringMatr);
    this.ring.matrixAutoUpdate = false;
    this.ring.matrix.multiply(this.initTranslateRing);


    var skyGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
    var cubeMaterials = [
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_bk.png'),
        side: THREE.DoubleSide
      }), //RIGHT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_ft.png'),
        side: THREE.DoubleSide
      }), //LEFT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_up.png'),
        side: THREE.DoubleSide
      }), //TOP SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_dn.png'),
        side: THREE.DoubleSide
      }), //BOTTOM SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_lf.png'),
        side: THREE.DoubleSide
      }), //FRONT SIDE
      new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load('img/miramar_rt.png'),
        side: THREE.DoubleSide
      }) //BACK S
    ];

    var cubeMaterial = new THREE.MeshFaceMaterial(cubeMaterials);
    var cube = new THREE.Mesh(skyGeometry, cubeMaterial);
    scene.add(this.ring);
    scene.add(cube);

    var horSpeed = 10;
    var vertSpeed = 5;

    var vertAngleCap = 40
    var vertAngle = 0
    var horAngle = 0

    this.resetY = new THREE.Matrix4().makeTranslation(1.0, 0.0, 1.0);

    var update = function () {


      var time = Date.now() * 0.0005;

      this.moveRingUp = new THREE.Matrix4().makeTranslation(0.0, 0.5, 0.0);
      this.moveRingDown = new THREE.Matrix4().makeTranslation(0.0, -0.5, 0.0);
      this.moveRingLeft = new THREE.Matrix4().makeTranslation(-0.5, 0.0, 0.0);
      this.moveRingRight = new THREE.Matrix4().makeTranslation(0.5, 0.0, 0.0);

      try {
        if (rotateDown) {
          if (vertAngle <= vertAngleCap && horAngle == 0) {
            model.scene.rotateX(THREE.Math.degToRad(vertSpeed));
            vertAngle += vertSpeed;
          }
          this.ring.matrix.premultiply(this.moveRingUp);
        }
        if (rotateLeft) {
    
            model.scene.rotateZ(THREE.Math.degToRad(-horSpeed));
            horAngle -= horSpeed;
            horAngle %= 360;
        
          this.ring.matrix.premultiply(this.moveRingRight);
        }
        if (rotateUp) {
          if (vertAngle >= -vertAngleCap && horAngle == 0) {
            model.scene.rotateX(THREE.Math.degToRad(-vertSpeed));
            vertAngle -= vertSpeed
          }

          this.ring.matrix.premultiply(this.moveRingDown);
        }
        if (rotateRight) {
  
            model.scene.rotateZ(THREE.Math.degToRad(horSpeed));
            horAngle += horSpeed;
            horAngle %= 360;
 
          this.ring.matrix.premultiply(this.moveRingLeft);
        }

        //stabilizes the vertical angle of the plane
        if (!rotateDown && !rotateUp && vertAngle != 0) {
          var adjustment = ((vertAngle < 0) ? 1 : -1) * vertSpeed;
          model.scene.rotateX(THREE.Math.degToRad(adjustment));
          vertAngle += adjustment
        }

        //stabilizes the horizontal angle of the plane
        if (!rotateLeft && !rotateRight && horAngle != 0) {

          var adjustment = horSpeed;


          //spin right defaults to stabilizing left, visa versa
          if (horAngle > 0) {
            adjustment *= -1;
          }

          //if the plane spins past 180 degrees, it will flip the way it stabilizes
          if (Math.abs(horAngle) > 180)
            adjustment *= -1;

          model.scene.rotateZ(THREE.Math.degToRad(adjustment));
          horAngle += adjustment;
          horAngle %= 360;
          console.log(horAngle);

        }

        //model.scene.position.x = Math.sin(time * 0.7) * 30;
      } catch (TypeError) {
        //console throws an error if the previous isn't in a try catch
      }
    };

    // draw scene
    var render = function () {
      this.rotZ1 = new THREE.Matrix4().makeRotationZ(THREE.Math.degToRad(1));
      this.ring.matrix.multiply(this.rotZ1);
      this.moveRingTowardsPlayer = new THREE.Matrix4().makeTranslation(0.0, 0.0, 0.5);
      this.ring.matrix.premultiply(this.moveRingTowardsPlayer);
      //this.moveRingTowardsPlayer = new THREE.matrixWorld().makeTranslation(0.0, 0.5, 0.0);
      renderer.render(scene, camera);

    };

    // run game loop: update, render, repeat
    var GameLoop = function () {
      requestAnimationFrame(GameLoop);

      update();
      render();
    };

    GameLoop();
  </script>
</body>

</html>